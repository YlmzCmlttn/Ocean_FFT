
/*
Practical Use:
In ocean simulation, this scalar P(k)
P(k) is used to determine the amplitude of each wave in a Fourier-based approach. 
Typically, you would take the square root of Pk
P(k) to get the amplitude, multiply by a random factor (often Gaussian distributed) to add randomness, 
and then use an inverse FFT to transform the frequency domain data 
into a spatial height field representing the ocean surface.

*/

#pragma kernel CSMain
RWTexture2D<float4> _HeightTex, _NormalTex;
float _FrameTime;
float _Wind_DirX;
float _Wind_DirY;
float _WindSpeed;
float _A;

#define PI 3.14159265358979323846


// Helper: Hash function for generating pseudorandom numbers from an integer
uint hash(uint x)
{
    x = (x << 13U) ^ x;
    return x * (x * x * 15731U + 789221U) + 1376312589U;
}

float hashFloat(uint n)
{
    // Convert the hashed value to a float in [0,1]
    return (hash(n) & 0x7fffffffU) / float(0x7fffffffU);
}

// Helper: Convert two uniform random numbers to a pair of Gaussian (normal)
// random numbers using the Box-Muller transform.
float2 UniformToGaussian(float u1, float u2)
{
    float R = sqrt(-2.0 * log(u1));
    float theta = 2.0 * PI * u2;
    return float2(R * cos(theta), R * sin(theta));
}



float PhillipsSpectrum(float A,float windSpeed,float2 windDirection, float2 waveVector)
{
    float magnitudeOfWaveVector = length(waveVector);
    if(magnitudeOfWaveVector < 0.0001f) return 0.0f;

    float L = windSpeed * windSpeed / 9.8f;
    float2 unitVectorOfWindDirection = normalize(windDirection);
    float DotProduct_Of_Normalize_Both_WaveVector_And_WindDirection = dot(normalize(waveVector),unitVectorOfWindDirection);
    float k = magnitudeOfWaveVector;
    float kw = DotProduct_Of_Normalize_Both_WaveVector_And_WindDirection;
    
    return A * exp(-1.0f/((k*L)*(k*L))) / (k*k*k*k) * (kw*kw);
}

// Generate the initial Fourier coefficient h0(k) as a complex number.
// h0(k) = 1/sqrt(2) * sqrt(P(k)) * (Gaussian random complex number)
float2 GenerateInitialFourierCoefficient(uint3 id, float2 waveVector,float Resolution)
{
    // Create a unique seed based on the thread's coordinates:
    uint seed = id.x + id.y * (uint)Resolution;
    
    // Generate two random floats in [0, 1]:
    float u1 = hashFloat(seed);
    float u2 = hashFloat(seed + 1);
    
    // Convert to a Gaussian random complex number (with zero mean, unit variance):
    float2 gauss = UniformToGaussian(u1, u2);
    
    // Compute the Phillips spectrum for this wave vector:
    float P = PhillipsSpectrum(_A, _WindSpeed, float2(_Wind_DirX, _Wind_DirY), waveVector);
    
    // Scale the random number by sqrt(P) and normalize:
    float amplitude = sqrt(P) / sqrt(2.0);
    return gauss * amplitude;
}





[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID) {
    float PhysicalDomainLength = 1024.0;
    float Resolution = 512.0;
    float n = id.x - Resolution/2.0f;
    float m = id.y - Resolution/2.0f;

    float2 WaveVector = float2(n,m) * 2.0 * PI / PhysicalDomainLength;
    //Calculates PhillipsSpectrum 
    float P = PhillipsSpectrum(_A,_WindSpeed,float2(_Wind_DirX,_Wind_DirY),WaveVector);

    //Generate the Initial Fourier Coefficients

    _HeightTex[id.xy] = P;
    _HeightTex[id.xy] = UniformToGaussian(float2(id.x/Resolution,id.y/Resolution)).xy;


    
}